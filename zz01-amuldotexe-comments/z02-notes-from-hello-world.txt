// Key differences between Generics, Functions and Traits in Rust:
//
// ┌───────────┬────────────────────────┬──────────────────────────────────────┬───────────────────────────┐
// │ Feature   │ Purpose                │ Example                              │ Key Properties            │
// ├───────────┼────────────────────────┼──────────────────────────────────────┼───────────────────────────┤
// │ Functions │ Standalone code blocks │ fn process(x: i32) -> i32 {          │ - Direct implementation   │
// │           │ with inputs/outputs    │     x + 1                            │ - Fixed types             │
// │           │                        │ }                                    │ - No polymorphism         │
// ├───────────┼────────────────────────┼──────────────────────────────────────┼───────────────────────────┤
// │ Generics  │ Type-parameterized     │ fn process<T>(x: T) -> T             │ - Compile-time resolved   │
// │           │ code reuse             │     where T: Add<Output=T> {         │ - Zero runtime cost       │
// │           │                        │     x + x                            │ - Type constraints        │
// │           │                        │ }                                    │                           │
// ├───────────┼────────────────────────┼──────────────────────────────────────┼───────────────────────────┤
// │ Traits    │ Shared behavior        │ trait Processor {                    │ - Runtime polymorphism    │
// │           │ interfaces             │     fn process(&self) -> i32;        │ - Dynamic dispatch        │
// │           │                        │ }                                    │ - Code reuse via impl     │
// └───────────┴────────────────────────┴──────────────────────────────────────┴───────────────────────────┘
//
// This table breaks down three core concepts in Rust's type system. Functions are your basic building blocks - 
// they just do one specific thing with specific types. Generics let you write code that works with multiple 
// types, like a function that can add any two numbers together. The compiler figures out the actual types at 
// compile time. Traits are like contracts that types can implement - they define shared behavior that 
// different types can provide their own versions of, like how different types can all implement Display to 
// show themselves as text. The cool thing is traits give you runtime flexibility through dynamic dispatch, 
// while generics give you compile-time optimization through monomorphization.

// Here are concrete examples:
//
// Note: While it's tempting to think of traits as "clusters of types with common behavior",
// that's not quite accurate. Traits define behavior (interface) that types can implement,
// but they don't group or cluster the types themselves. A type can implement many traits,
// and traits don't know about which types implement them. Think of traits more like 
// contracts or interfaces that types can choose to fulfill.


```rust
// Regular function - fixed types
fn add_ints(x: i32, y: i32) -> i32 {
    x + y
}

// Generic function - works with any type T that implements Add
fn add_generic<T: std::ops::Add<Output = T>>(x: T, y: T) -> T {
    x + y
}

// This generic function demonstrates several key concepts:
//
// 1. Type Parameter <T>: Makes the function work with any type T that meets the constraints
//
// 2. Trait Bound (std::ops::Add<Output = T>): 
//    - Requires type T to implement the Add trait
//    - Output = T means adding two Ts must produce another T
//    - Examples: numbers (i32 + i32 = i32), strings (String + String = String)
//
// 3. Parameters (x: T, y: T):
//    - Both must be the same type T
//    - Compiler enforces type safety
//
// At compile time, Rust will create specialized versions of this function
// for each concrete type used (called monomorphization)

// Trait - defines shared behavior
trait Printable {
    fn print(&self);
}
// In this example, 2 types implement this trait:
// 1. Point struct - implements print() to show x,y coordinates 
// 2. Circle struct - implements print() to show radius
//
// The actual function definitions appear in impl blocks after each struct,
// using the syntax:
//   impl Printable for StructName { 
//     fn print(&self) { ... }
//   }

// Different types can implement the trait
struct Point {
    x: i32,
    y: i32,
}

impl Printable for Point {
    fn print(&self) {
        println!("Point({}, {})", self.x, self.y);
    }
}

struct Circle {
    radius: f64,
}

impl Printable for Circle {
    fn print(&self) {
        println!("Circle(r={})", self.radius);
    }
}

// Function that uses trait object for runtime polymorphism
fn print_shape(shape: &dyn Printable) {
    shape.print();
}
```
Q: What is &dyn?
A: &dyn is Rust's syntax for trait objects - it means "reference to any type that implements this trait"
- & indicates it's borrowed (non-owning reference)
- dyn indicates dynamic dispatch will be used
- Size is known at runtime (2 pointers: data + vtable)
- Enables runtime polymorphism
Q2: Runtime vs Compile-time Polymorphism Across Languages
┌────────────┬────────────────────┬───────────────────────┐
│ Language   │ Runtime (Dynamic)  │ Compile-time (Static) │
├────────────┼────────────────────┼───────────────────────┤
│ Rust       │ &dyn Trait         │ Generic <T>           │
│            │ (vtable lookup)    │ (monomorphization)    │
├────────────┼────────────────────┼───────────────────────┤
│ Java       │ Interface          │ Generics <T>           │
│           │ (vtable lookup)   │ (type erasure)        │
├────────────┼────────────────────┼───────────────────────┤
│ Go         │ Interface         │ No generics pre-1.18   │
│           │ (interface table)  │ (type parameters now) │
├────────────┼────────────────────┼───────────────────────┤
│ Python     │ Duck typing       │ Type hints (optional) │
│           │ (method lookup)    │ (runtime checking)    │
└────────────┴────────────────────┴───────────────────────┘
ELI15: Think of polymorphism like a universal remote control in context of types. You have two ways to make it work:
Runtime (Dynamic) is like a learning remote - when you press a button, it figures out what to do 
by checking a little instruction manual inside (the vtable). It's flexible but slightly slower
since it has to look up what to do each time.
Compile-time (Static) is like having separate remotes for each device. The compiler makes a 
specialized version for each type (in Rust, this is called monomorphization). It's faster because
there's no lookup needed - it knows exactly what to do. But it makes your program bigger since
you need separate code for each type.
Rust lets you choose which approach you want:
- Use &dyn Trait when you need flexibility and don't mind the small runtime cost
- Use generics <T> when you want maximum speed and don't mind larger binary size

ELI15: vtable & monomorphization explained with a restaurant analogy:

vtable (&dyn Trait):
Imagine a restaurant with a menu (trait) and different dishes (implementations).
When a customer (your code) orders "today's special" (trait object):

Menu (Trait)           vtable                  Implementation
┌──────────┐     ┌─────────────────┐     ┌─────────────────┐
│ Order    │ --> │ Pizza::make()   │ --> │ Pizza           │
│ Make     │     │ Pizza::serve()  │     │ - make()        │
│ Serve    │     └─────────────────┘     │ - serve()       │
└──────────┘                             └─────────────────┘

The waiter (vtable) looks up how to make/serve that specific dish at runtime.

monomorphization (generics <T>):
Instead of a lookup, the kitchen (compiler) creates separate specialized
recipes for each dish type at compile time:

Before:                After Monomorphization:
┌──────────┐          ┌─────────────┐  ┌─────────────┐
│serve<T>  │  ------> │serve_pizza()|  │serve_pasta()│
│{...}     │          │{...}        |  │{...}        │
└──────────┘          └─────────────┘  └─────────────┘

Faster to execute but takes more space - like having separate cooking
stations for each dish type!
Compile-time vs Runtime Polymorphism in Rust: Tradeoffs & Usage Guide

Compile-time (Generics <T>):
✅ Pros:
- Zero runtime overhead - all code is specialized at compile time
- Better optimization opportunities for the compiler
- Type checking at compile time catches errors early
- No runtime cost for virtual dispatch

❌ Cons:
- Larger binary size due to monomorphization (code duplication)
- Longer compile times
- All possible types must be known at compile time
- Can't use dynamic loading/plugins

Runtime (dyn Trait):
✅ Pros:
- Smaller binary size - no code duplication
- Faster compilation
- Supports dynamic loading/plugins
- Can handle types not known at compile time

❌ Cons:
- Runtime overhead from vtable lookups:
  ┌─────────────┐         ┌─────────────┐
  │ Your Code   │   1️⃣    │   vtable    │
  │ calls       │ ───────>│ (lookup     │
  │ method()    │         │  table)     │
  └─────────────┘         └──────┬──────┘
                                 │
                                 │ 2️⃣
                                 ▼
                         ┌─────────────┐
                         │ Actual      │
                         │ Implementation│
                         └─────────────┘

  Each method call needs two steps:
  1. Find method address in vtable
  2. Jump to that address
  
  vs generics which directly call the implementation:
  ┌─────────────┐    
  │ Your Code   │ ──────> Implementation
  └─────────────┘    
- Less optimization potential
- Heap allocation required for trait objects
- Can't use associated types or const generics

Vtable Contents:

The vtable is created at compile time and contains:
1. Pointer to destructor
2. Size of concrete type
3. Alignment of concrete type 
4. Function pointers for ALL trait methods

Example vtable for Display trait:
┌─────────────────────┐
│ destructor_fn_ptr   │ 
├─────────────────────┤
│ size: usize         │
├─────────────────────┤
│ align: usize        │
├─────────────────────┤
│ fmt_fn_ptr          │ -> Points to actual fmt() implementation
└─────────────────────┘

So yes - the vtable has all the same functions as generics would have, determined at compile time. The only difference is generics generate specialized code for each type, while vtables store function pointers to a single implementation.

Key points:
- Vtable contents are fixed at compile time
- One vtable per (trait, type) combination
- Runtime cost is just pointer indirection
- No runtime function resolution needed

Q: No, there are important differences:
1. Generics generate specialized code that is fully type-checked and optimized for each concrete type
2. Vtables only store function pointers - the actual implementations are type-checked but not specialized/optimized for each type
3. Generics can use static dispatch (direct function calls) while vtables require dynamic dispatch (pointer indirection)
4. Generics can leverage type information for optimizations that aren't possible with vtables


When to Use What:

Use Compile-time (<T>) when:
- Performance is critical
- Types are known at compile time
- Working with embedded systems/no_std
- Using const generics or associated types

Example:
```rust
fn process_data<T: Display>(data: T) { ... }
```
//
// Use Runtime (dyn) when:
// - Need dynamic dispatch/plugins
// - Binary size is a concern
// - Types determined at runtime
// - Building public APIs
//
// Example:
```rust
fn process_data(data: Box<dyn Display>) { ... }
```
//
// Real-world Example:
// - Iterator combinators use generics for zero-cost abstractions
// - GUI frameworks often use dyn Trait for plugin systems
